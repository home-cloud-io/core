package system

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	dv1 "github.com/home-cloud-io/core/api/platform/daemon/v1"
	v1 "github.com/home-cloud-io/core/api/platform/server/v1"
	"github.com/robfig/cron/v3"

	"github.com/home-cloud-io/core/services/platform/server/async"
	kvclient "github.com/home-cloud-io/core/services/platform/server/kv-client"
	"github.com/steady-bytes/draft/pkg/chassis"
)

type (
	OS interface {
		// CheckForOSUpdates will run the Nix commands to check for any NixOS updates to install.
		CheckForOSUpdates(ctx context.Context, logger chassis.Logger) (*v1.CheckForSystemUpdatesResponse, error)
		// InstallOSUpdate will install the update (if any) generated by CheckForOSUpdates.
		InstallOSUpdate() error
		// AutoUpdateOS will check for and install any OS (including Daemon) updates on a schedule. It is
		// designed to be called at bootup.
		AutoUpdateOS(logger chassis.Logger)
		// UpdateOS will check for and install any OS (including Daemon) updates one time.
		UpdateOS(ctx context.Context, logger chassis.Logger) error
		// EnableWireguard will initialize the Wireguard server on the host
		EnableWireguard(ctx context.Context, logger chassis.Logger) error
		// DisableWireguard will disable the Wireguard server on the host
		DisableWireguard(ctx context.Context, logger chassis.Logger) error
	}
)

// OS

func (c *controller) CheckForOSUpdates(ctx context.Context, logger chassis.Logger) (*v1.CheckForSystemUpdatesResponse, error) {
	if !c.systemUpdateLock.TryLock() {
		logger.Warn("call to check for system updates while another check is already in progress")
		return nil, fmt.Errorf("system update check already in progress")
	}
	defer c.systemUpdateLock.Unlock()

	var (
		response = &v1.CheckForSystemUpdatesResponse{}
	)

	// get the os update diff from the daemon
	listener := async.RegisterListener(ctx, c.broadcaster, &async.ListenerOptions[*dv1.OSUpdateDiff]{
		Callback: func(event *dv1.OSUpdateDiff) (bool, error) {
			response.OsDiff = event.Description
			return true, nil
		},
		// compiling the new OS can take a while
		Timeout: 30 * time.Minute,
	})
	err := com.Send(&dv1.ServerMessage{
		Message: &dv1.ServerMessage_RequestOsUpdateDiff{},
	})
	if err != nil {
		return nil, err
	}
	err = listener.Listen(ctx)
	if err != nil {
		return nil, err
	}

	// get the current daemon version from the daemon
	listener = async.RegisterListener(ctx, c.broadcaster, &async.ListenerOptions[*dv1.CurrentDaemonVersion]{
		Callback: func(event *dv1.CurrentDaemonVersion) (bool, error) {
			if event.Error != "" {
				logger.WithError(errors.New(event.Error)).Error("failed to get current daemon version")
				return true, errors.New(event.Error)
			}
			response.DaemonVersions = &v1.DaemonVersions{
				Current: &v1.DaemonVersion{
					Version:    event.Version,
					VendorHash: event.VendorHash,
					SrcHash:    event.SrcHash,
				},
			}
			return true, nil
		},
	})
	err = com.Send(&dv1.ServerMessage{
		Message: &dv1.ServerMessage_RequestCurrentDaemonVersion{},
	})
	if err != nil {
		return nil, err
	}
	err = listener.Listen(ctx)
	if err != nil {
		return nil, err
	}

	// get latest available daemon version
	latest, err := getLatestDaemonVersion()
	if err != nil {
		return nil, err
	}
	response.DaemonVersions.Latest = latest

	return response, nil
}

func (c *controller) InstallOSUpdate() error {
	err := com.Send(&dv1.ServerMessage{
		Message: &dv1.ServerMessage_InstallOsUpdateCommand{},
	})
	if err != nil {
		return err
	}
	return nil
}

func (c *controller) AutoUpdateOS(logger chassis.Logger) {
	cr := cron.New()
	f := func() {
		ctx := context.Background()
		err := c.UpdateOS(ctx, logger)
		if err != nil {
			logger.WithError(err).Error("failed to run auto os update job")
		}
	}
	cron := chassis.GetConfig().GetString(osAutoUpdateCronConfigKey)
	logger.WithField("cron", cron).Info("setting os auto-update interval")
	_, err := cr.AddFunc(cron, f)
	if err != nil {
		logger.WithError(err).Panic("failed to initialize auto-update for os")
	}
	cr.Start()
}

func (u *controller) UpdateOS(ctx context.Context, logger chassis.Logger) error {
	logger.Info("updating os")
	settings := &v1.DeviceSettings{}
	err := kvclient.Get(ctx, kvclient.DEFAULT_DEVICE_SETTINGS_KEY, settings)
	if err != nil {
		logger.WithError(err).Error("failed to get device settings")
		return err
	}

	if !settings.AutoUpdateOs {
		logger.Info("auto update sytem not enabled")
		return nil
	}

	updates, err := u.CheckForOSUpdates(ctx, logger)
	if err != nil {
		logger.WithError(err).Error("failed to check for system updates")
		return err
	}

	// if the daemon needs updating, install it along with the os updates
	// otherwise just install the os update
	if updates.DaemonVersions.Current.Version != updates.DaemonVersions.Latest.Version &&
		updates.DaemonVersions.Current.SrcHash != updates.DaemonVersions.Latest.SrcHash &&
		updates.DaemonVersions.Current.VendorHash != updates.DaemonVersions.Latest.VendorHash {
		logger.Info("updating daemon along with os")
		err = com.Send(&dv1.ServerMessage{
			Message: &dv1.ServerMessage_ChangeDaemonVersionCommand{
				ChangeDaemonVersionCommand: &dv1.ChangeDaemonVersionCommand{
					Version:    updates.DaemonVersions.Latest.Version,
					VendorHash: updates.DaemonVersions.Latest.VendorHash,
					SrcHash:    updates.DaemonVersions.Latest.SrcHash,
				},
			},
		})
	} else {
		err = com.Send(&dv1.ServerMessage{
			Message: &dv1.ServerMessage_InstallOsUpdateCommand{},
		})
	}
	if err != nil {
		logger.WithError(err).Error("failed to install system update")
		return err
	}

	return nil
}

func (c *controller) EnableWireguard(ctx context.Context, logger chassis.Logger) error {
	var (
		err error
	)

	// create wireguard config
	wgInterface := &dv1.WireguardInterface{
		Id:   uuid.New().String(),
		Name: DefaultWireguardInterface,
		Ips: []string{
			"10.100.0.1/24",
		},
		ListenPort: 51820,
		Peers:      []*dv1.WireguardPeer{},
	}

	// command daemon to initialize
	var publicKey string
	listener := async.RegisterListener(ctx, c.broadcaster, &async.ListenerOptions[*dv1.WireguardInterfaceAdded]{
		Callback: func(event *dv1.WireguardInterfaceAdded) (bool, error) {
			if event.Error != "" {
				return true, fmt.Errorf(event.Error)
			}
			publicKey = event.PublicKey
			return true, nil
		},
		Timeout: 300 * time.Second,
	})

	err = com.Send(&dv1.ServerMessage{
		Message: &dv1.ServerMessage_AddWireguardInterface{
			AddWireguardInterface: &dv1.AddWireguardInterface{
				Interface: wgInterface,
			},
		},
	})
	if err != nil {
		return err
	}
	err = listener.Listen(ctx)
	if err != nil {
		return err
	}

	// set STUN server on daemon
	listener = async.RegisterListener(ctx, c.broadcaster, &async.ListenerOptions[*dv1.STUNServerSet]{
		Callback: func(event *dv1.STUNServerSet) (bool, error) {
			if event.Error != "" {
				return true, fmt.Errorf(event.Error)
			}
			return true, nil
		},
	})
	err = com.Send(&dv1.ServerMessage{
		Message: &dv1.ServerMessage_SetStunServerCommand{
			SetStunServerCommand: &dv1.SetSTUNServerCommand{
				ServerAddress:      DefaultSTUNServerAddress,
				WireguardInterface: DefaultWireguardInterface,
			},
		},
	})
	if err != nil {
		return err
	}
	err = listener.Listen(ctx)
	if err != nil {
		return err
	}

	// enable feature in blueprint
	settings := &v1.DeviceSettings{}
	err = kvclient.Get(ctx, kvclient.DEFAULT_DEVICE_SETTINGS_KEY, settings)
	if err != nil {
		return err
	}
	settings.SecureTunnelingSettings = &v1.SecureTunnelingSettings{
		Enabled: true,
		WireguardInterfaces: []*v1.WireguardInterface{
			{
				Id:             wgInterface.Id,
				Name:           wgInterface.Name,
				Port:           int32(wgInterface.ListenPort),
				PublicKey:      publicKey,
				StunServer:     DefaultSTUNServerAddress,
				LocatorServers: []string{},
			},
		},
	}
	_, err = kvclient.Set(ctx, kvclient.DEFAULT_DEVICE_SETTINGS_KEY, settings)
	if err != nil {
		return fmt.Errorf("failed to save settings")
	}

	return nil
}

func (c *controller) DisableWireguard(ctx context.Context, logger chassis.Logger) error {
	var (
		err error
	)

	listener := async.RegisterListener(ctx, c.broadcaster, &async.ListenerOptions[*dv1.WireguardInterfaceRemoved]{
		Callback: func(event *dv1.WireguardInterfaceRemoved) (bool, error) {
			if event.Error != "" {
				return true, fmt.Errorf(event.Error)
			}
			return true, nil
		},
		Timeout: 30 * time.Second,
	})
	err = com.Send(&dv1.ServerMessage{
		Message: &dv1.ServerMessage_RemoveWireguardInterface{
			RemoveWireguardInterface: &dv1.RemoveWireguardInterface{
				Name: DefaultWireguardInterface,
			},
		},
	})
	if err != nil {
		return err
	}
	err = listener.Listen(ctx)
	if err != nil {
		return err
	}

	// disable feature in blueprint
	settings := &v1.DeviceSettings{}
	err = kvclient.Get(ctx, kvclient.DEFAULT_DEVICE_SETTINGS_KEY, settings)
	if err != nil {
		return err
	}
	settings.SecureTunnelingSettings = &v1.SecureTunnelingSettings{
		Enabled:             false,
		WireguardInterfaces: []*v1.WireguardInterface{},
	}
	_, err = kvclient.Set(ctx, kvclient.DEFAULT_DEVICE_SETTINGS_KEY, settings)
	if err != nil {
		return fmt.Errorf("failed to save settings")
	}

	return nil
}
