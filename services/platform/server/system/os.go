package system

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	dv1 "github.com/home-cloud-io/core/api/platform/daemon/v1"
	v1 "github.com/home-cloud-io/core/api/platform/server/v1"
	"github.com/robfig/cron/v3"
	"golang.zx2c4.com/wireguard/wgctrl/wgtypes"

	"github.com/home-cloud-io/core/services/platform/server/async"
	kvclient "github.com/home-cloud-io/core/services/platform/server/kv-client"
	"github.com/steady-bytes/draft/pkg/chassis"
)

type (
	OS interface {
		// CheckForOSUpdates will run the Nix commands to check for any NixOS updates to install.
		CheckForOSUpdates(ctx context.Context, logger chassis.Logger) (*v1.CheckForSystemUpdatesResponse, error)
		// InstallOSUpdate will install the update (if any) generated by CheckForOSUpdates.
		InstallOSUpdate() error
		// AutoUpdateOS will check for and install any OS (including Daemon) updates on a schedule. It is
		// designed to be called at bootup.
		AutoUpdateOS(logger chassis.Logger)
		// UpdateOS will check for and install any OS (including Daemon) updates one time.
		UpdateOS(ctx context.Context, logger chassis.Logger) error
		// EnableWireguard will initialize the Wireguard server on the host and save the configuration to Blueprint
		EnableWireguard(ctx context.Context, logger chassis.Logger) error
		// DisableWireguard will disable the Wireguard server on the host and delete the configuration from Blueprint
		DisableWireguard(ctx context.Context, logger chassis.Logger) error
	}
)

// OS

func (c *controller) CheckForOSUpdates(ctx context.Context, logger chassis.Logger) (*v1.CheckForSystemUpdatesResponse, error) {
	if !c.systemUpdateLock.TryLock() {
		logger.Warn("call to check for system updates while another check is already in progress")
		return nil, fmt.Errorf("system update check already in progress")
	}
	defer c.systemUpdateLock.Unlock()

	var (
		response = &v1.CheckForSystemUpdatesResponse{}
	)

	// get the os update diff from the daemon
	done := make(chan bool)
	go async.RegisterListener(ctx, c.broadcaster, &async.ListenerOptions[*dv1.OSUpdateDiff]{
		Callback: func(event *dv1.OSUpdateDiff) (bool, error) {
			response.OsDiff = event.Description
			done <- true
			return true, nil
		},
	}).Listen(ctx)
	err := com.Send(&dv1.ServerMessage{
		Message: &dv1.ServerMessage_RequestOsUpdateDiff{},
	})
	if err != nil {
		return nil, err
	}
	<-done

	// get the current daemon version from the daemon
	done = make(chan bool)
	go async.RegisterListener(ctx, c.broadcaster, &async.ListenerOptions[*dv1.CurrentDaemonVersion]{
		Callback: func(event *dv1.CurrentDaemonVersion) (bool, error) {
			response.DaemonVersions = &v1.DaemonVersions{
				Current: &v1.DaemonVersion{
					Version:    event.Version,
					VendorHash: event.VendorHash,
					SrcHash:    event.SrcHash,
				},
			}
			done <- true
			return true, nil
		},
	}).Listen(ctx)
	err = com.Send(&dv1.ServerMessage{
		Message: &dv1.ServerMessage_RequestCurrentDaemonVersion{},
	})
	if err != nil {
		return nil, err
	}

	// get latest available daemon version
	latest, err := getLatestDaemonVersion()
	if err != nil {
		return nil, err
	}
	response.DaemonVersions.Latest = latest

	return response, nil
}

func (c *controller) InstallOSUpdate() error {
	err := com.Send(&dv1.ServerMessage{
		Message: &dv1.ServerMessage_InstallOsUpdateCommand{},
	})
	if err != nil {
		return err
	}
	return nil
}

func (c *controller) AutoUpdateOS(logger chassis.Logger) {
	cr := cron.New()
	f := func() {
		ctx := context.Background()
		err := c.UpdateOS(ctx, logger)
		if err != nil {
			logger.WithError(err).Error("failed to run auto os update job")
		}
	}
	cron := chassis.GetConfig().GetString(osAutoUpdateCronConfigKey)
	logger.WithField("cron", cron).Info("setting os auto-update interval")
	_, err := cr.AddFunc(cron, f)
	if err != nil {
		logger.WithError(err).Panic("failed to initialize auto-update for os")
	}
	cr.Start()
}

func (u *controller) UpdateOS(ctx context.Context, logger chassis.Logger) error {
	logger.Info("updating os")
	settings := &v1.DeviceSettings{}
	err := kvclient.Get(ctx, kvclient.DEFAULT_DEVICE_SETTINGS_KEY, settings)
	if err != nil {
		logger.WithError(err).Error("failed to get device settings")
		return err
	}

	if !settings.AutoUpdateOs {
		logger.Info("auto update sytem not enabled")
		return nil
	}

	updates, err := u.CheckForOSUpdates(ctx, logger)
	if err != nil {
		logger.WithError(err).Error("failed to check for system updates")
		return err
	}

	// if the daemon needs updating, install it along with the os updates
	// otherwise just install the os update
	if updates.DaemonVersions.Current != updates.DaemonVersions.Latest {
		err = com.Send(&dv1.ServerMessage{
			Message: &dv1.ServerMessage_ChangeDaemonVersionCommand{
				ChangeDaemonVersionCommand: &dv1.ChangeDaemonVersionCommand{
					Version:    updates.DaemonVersions.Latest.Version,
					VendorHash: updates.DaemonVersions.Latest.VendorHash,
					SrcHash:    updates.DaemonVersions.Latest.SrcHash,
				},
			},
		})
	} else {
		err = com.Send(&dv1.ServerMessage{
			Message: &dv1.ServerMessage_InstallOsUpdateCommand{},
		})
	}
	if err != nil {
		logger.WithError(err).Error("failed to install system update")
		return err
	}

	return nil
}

func (c *controller) EnableWireguard(ctx context.Context, logger chassis.Logger) error {
	var (
		err    error
		config = &dv1.WireguardConfig{}
	)

	// check if wireguard is already enabled
	result, err := kvclient.List(ctx, config)
	if err != nil {
		return err
	}
	if result != nil {
		logger.Warn("the Wireguard server is already enabled")
		return nil
	}

	key, err := wgtypes.GeneratePrivateKey()
	if err != nil {
		return err
	}

	// create wireguard config
	config = &dv1.WireguardConfig{
		Interfaces: []*dv1.WireguardInterface{
			{
				Id:         uuid.New().String(),
				Name:       DefaultWireguardInterface,
				PrivateKey: key.String(),
				Ips: []string{
					"10.100.0.1/24",
				},
				ListenPort: 51820,
				Peers:      []*dv1.WireguardPeer{},
			},
		},
	}

	// command daemon to initialize
	done := make(chan bool)
	var listenerErr error
	go func() {
		listenerErr = async.RegisterListener(ctx, c.broadcaster, &async.ListenerOptions[*dv1.WireguardInterfaceAdded]{
			Callback: func(event *dv1.WireguardInterfaceAdded) (bool, error) {
				done <- true
				if event.Error != nil {
					return true, fmt.Errorf(event.Error.Error)
				}
				return true, nil
			},
			Timeout: 30 * time.Second,
		}).Listen(ctx)
		if listenerErr != nil {
			done <- true
		}
	}()
	err = com.Send(&dv1.ServerMessage{
		Message: &dv1.ServerMessage_AddWireguardInterface{
			AddWireguardInterface: &dv1.AddWireguardInterface{
				// TODO: handle this better
				Interface: config.Interfaces[0],
			},
		},
	})
	if err != nil {
		return err
	}
	<-done
	if listenerErr != nil {
		return listenerErr
	}

	// save config to blueprint
	_, err = kvclient.Set(ctx, kvclient.WIREGUARD_CONFIG_KEY, config)
	if err != nil {
		return err
	}

	// enable feature in blueprint
	settings := &v1.DeviceSettings{}
	err = kvclient.Get(ctx, kvclient.DEFAULT_DEVICE_SETTINGS_KEY, settings)
	if err != nil {
		return err
	}
	settings.LocatorSettings = &v1.LocatorSettings{
		Enabled:  true,
		Locators: make([]*v1.Locator, 0),
	}
	_, err = kvclient.Set(ctx, kvclient.DEFAULT_DEVICE_SETTINGS_KEY, settings)
	if err != nil {
		return fmt.Errorf("failed to save settings")
	}

	return nil
}

func (c *controller) DisableWireguard(ctx context.Context, logger chassis.Logger) error {
	var (
		err error
	)

	// disable on daemon
	done := make(chan bool)
	var listenerErr error
	go func() {
		listenerErr = async.RegisterListener(ctx, c.broadcaster, &async.ListenerOptions[*dv1.WireguardInterfaceRemoved]{
			Callback: func(event *dv1.WireguardInterfaceRemoved) (bool, error) {
				done <- true
				if event.Error != nil {
					return true, fmt.Errorf(event.Error.Error)
				}
				return true, nil
			},
			Timeout: 30 * time.Second,
		}).Listen(ctx)
		if listenerErr != nil {
			done <- true
		}
	}()
	err = com.Send(&dv1.ServerMessage{
		Message: &dv1.ServerMessage_RemoveWireguardInterface{
			RemoveWireguardInterface: &dv1.RemoveWireguardInterface{
				Name: DefaultWireguardInterface,
			},
		},
	})
	if err != nil {
		return err
	}
	<-done
	if listenerErr != nil {
		return listenerErr
	}

	// delete config from blueprint
	_, err = kvclient.Delete(ctx, kvclient.WIREGUARD_CONFIG_KEY, &dv1.WireguardConfig{})
	if err != nil {
		return err
	}

	return nil
}
