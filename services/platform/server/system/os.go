package system

import (
	"context"
	"fmt"

	"connectrpc.com/connect"
	"github.com/google/uuid"
	dv1 "github.com/home-cloud-io/core/api/platform/daemon/v1"
	v1 "github.com/home-cloud-io/core/api/platform/server/v1"
	"github.com/robfig/cron/v3"

	kvclient "github.com/home-cloud-io/core/services/platform/server/kv-client"
	"github.com/steady-bytes/draft/pkg/chassis"
)

type (
	OS interface {
		// CheckForOSUpdates will run the Nix commands to check for any NixOS updates to install.
		CheckForOSUpdates(ctx context.Context, logger chassis.Logger) (*v1.CheckForSystemUpdatesResponse, error)
		// InstallOSUpdate will install the update (if any) generated by CheckForOSUpdates.
		InstallOSUpdate() error
		// AutoUpdateOS will check for and install any OS (including Daemon) updates on a schedule. It is
		// designed to be called at bootup.
		AutoUpdateOS(logger chassis.Logger)
		// UpdateOS will check for and install any OS (including Daemon) updates one time.
		UpdateOS(ctx context.Context, logger chassis.Logger) error
		// EnableWireguard will initialize the Wireguard server on the host
		EnableWireguard(ctx context.Context, logger chassis.Logger) error
		// DisableWireguard will disable the Wireguard server on the host
		DisableWireguard(ctx context.Context, logger chassis.Logger) error
	}
)

var CurrentStats *dv1.SystemStats

// OS

func (c *controller) CheckForOSUpdates(ctx context.Context, logger chassis.Logger) (*v1.CheckForSystemUpdatesResponse, error) {
	if !c.systemUpdateLock.TryLock() {
		logger.Warn("call to check for system updates while another check is already in progress")
		return nil, fmt.Errorf("system update check already in progress")
	}
	defer c.systemUpdateLock.Unlock()

	var (
		resp = &v1.CheckForSystemUpdatesResponse{}
	)

	// TODO: check talos api through daemon

	return resp, nil
}

func (c *controller) InstallOSUpdate() error {
	// TODO: update using talos api?
	return nil
}

func (c *controller) AutoUpdateOS(logger chassis.Logger) {
	cr := cron.New()
	f := func() {
		ctx := context.Background()
		err := c.UpdateOS(ctx, logger)
		if err != nil {
			logger.WithError(err).Error("failed to run auto os update job")
		}
	}
	cron := chassis.GetConfig().GetString(osAutoUpdateCronConfigKey)
	logger.WithField("cron", cron).Info("setting os auto-update interval")
	_, err := cr.AddFunc(cron, f)
	if err != nil {
		logger.WithError(err).Panic("failed to initialize auto-update for os")
	}
	cr.Start()
}

func (u *controller) UpdateOS(ctx context.Context, logger chassis.Logger) error {
	logger.Info("updating os")
	settings := &v1.DeviceSettings{}
	err := kvclient.Get(ctx, kvclient.DEFAULT_DEVICE_SETTINGS_KEY, settings)
	if err != nil {
		logger.WithError(err).Error("failed to get device settings")
		return err
	}

	if !settings.AutoUpdateOs {
		logger.Info("auto update sytem not enabled")
		return nil
	}

	_, err = u.CheckForOSUpdates(ctx, logger)
	if err != nil {
		logger.WithError(err).Error("failed to check for system updates")
		return err
	}

	// TODO: execute updates

	return nil
}

func (c *controller) EnableWireguard(ctx context.Context, logger chassis.Logger) error {
	var (
		err error
	)

	// create wireguard config
	wgInterface := &dv1.WireguardInterface{
		Id:   uuid.New().String(),
		Name: DefaultWireguardInterface,
		Ips: []string{
			"10.100.0.1/24",
		},
		ListenPort: 51820,
		Peers:      []*dv1.WireguardPeer{},
	}

	// command daemon to add wireguard interface
	resp, err := c.daemonClient.AddWireguardInterface(ctx, &connect.Request[dv1.AddWireguardInterfaceRequest]{
		Msg: &dv1.AddWireguardInterfaceRequest{
			Interface: wgInterface,
		},
	})
	if err != nil {
		return err
	}
	publicKey := resp.Msg.PublicKey

	// set STUN server on daemon
	_, err = c.daemonClient.SetSTUNServer(ctx, &connect.Request[dv1.SetSTUNServerRequest]{
		Msg: &dv1.SetSTUNServerRequest{
			ServerAddress:      DefaultSTUNServerAddress,
			WireguardInterface: DefaultWireguardInterface,
		},
	})
	if err != nil {
		return err
	}

	// enable feature in blueprint
	settings := &v1.DeviceSettings{}
	err = kvclient.Get(ctx, kvclient.DEFAULT_DEVICE_SETTINGS_KEY, settings)
	if err != nil {
		return err
	}
	settings.SecureTunnelingSettings = &v1.SecureTunnelingSettings{
		Enabled: true,
		WireguardInterfaces: []*v1.WireguardInterface{
			{
				Id:             wgInterface.Id,
				Name:           wgInterface.Name,
				Port:           int32(wgInterface.ListenPort),
				PublicKey:      publicKey,
				StunServer:     DefaultSTUNServerAddress,
				LocatorServers: []string{},
			},
		},
	}
	_, err = kvclient.Set(ctx, kvclient.DEFAULT_DEVICE_SETTINGS_KEY, settings)
	if err != nil {
		return fmt.Errorf("failed to save settings")
	}

	return nil
}

func (c *controller) DisableWireguard(ctx context.Context, logger chassis.Logger) error {
	var (
		err error
	)

	_, err = c.daemonClient.RemoveWireguardInterface(ctx, &connect.Request[dv1.RemoveWireguardInterfaceRequest]{
		Msg: &dv1.RemoveWireguardInterfaceRequest{
			Name: DefaultWireguardInterface,
		},
	})
	if err != nil {
		return err
	}

	// disable feature in blueprint
	settings := &v1.DeviceSettings{}
	err = kvclient.Get(ctx, kvclient.DEFAULT_DEVICE_SETTINGS_KEY, settings)
	if err != nil {
		return err
	}
	settings.SecureTunnelingSettings = &v1.SecureTunnelingSettings{
		Enabled:             false,
		WireguardInterfaces: []*v1.WireguardInterface{},
	}
	_, err = kvclient.Set(ctx, kvclient.DEFAULT_DEVICE_SETTINGS_KEY, settings)
	if err != nil {
		return fmt.Errorf("failed to save settings")
	}

	return nil
}
