// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: platform/locator/v1/locator.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RegisterRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterRequestMultiError, or nil if none found.
func (m *RegisterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountToken

	// no validation rules for ServerId

	if len(errors) > 0 {
		return RegisterRequestMultiError(errors)
	}

	return nil
}

// RegisterRequestMultiError is an error wrapping multiple validation errors
// returned by RegisterRequest.ValidateAll() if the designated constraints
// aren't met.
type RegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterRequestMultiError) AllErrors() []error { return m }

// RegisterRequestValidationError is the validation error returned by
// RegisterRequest.Validate if the designated constraints aren't met.
type RegisterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterRequestValidationError) ErrorName() string { return "RegisterRequestValidationError" }

// Error satisfies the builtin error interface
func (e RegisterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterRequestValidationError{}

// Validate checks the field values on RegisterResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterResponseMultiError, or nil if none found.
func (m *RegisterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RefreshToken

	// no validation rules for AccessToken

	if len(errors) > 0 {
		return RegisterResponseMultiError(errors)
	}

	return nil
}

// RegisterResponseMultiError is an error wrapping multiple validation errors
// returned by RegisterResponse.ValidateAll() if the designated constraints
// aren't met.
type RegisterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterResponseMultiError) AllErrors() []error { return m }

// RegisterResponseValidationError is the validation error returned by
// RegisterResponse.Validate if the designated constraints aren't met.
type RegisterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterResponseValidationError) ErrorName() string { return "RegisterResponseValidationError" }

// Error satisfies the builtin error interface
func (e RegisterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterResponseValidationError{}

// Validate checks the field values on LocateRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LocateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LocateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LocateRequestMultiError, or
// nil if none found.
func (m *LocateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LocateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServerId

	if all {
		switch v := interface{}(m.GetBody()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LocateRequestValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LocateRequestValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBody()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LocateRequestValidationError{
				field:  "Body",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LocateRequestMultiError(errors)
	}

	return nil
}

// LocateRequestMultiError is an error wrapping multiple validation errors
// returned by LocateRequest.ValidateAll() if the designated constraints
// aren't met.
type LocateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocateRequestMultiError) AllErrors() []error { return m }

// LocateRequestValidationError is the validation error returned by
// LocateRequest.Validate if the designated constraints aren't met.
type LocateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocateRequestValidationError) ErrorName() string { return "LocateRequestValidationError" }

// Error satisfies the builtin error interface
func (e LocateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocateRequestValidationError{}

// Validate checks the field values on LocateRequestBody with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LocateRequestBody) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LocateRequestBody with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LocateRequestBodyMultiError, or nil if none found.
func (m *LocateRequestBody) ValidateAll() error {
	return m.validate(true)
}

func (m *LocateRequestBody) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServerId

	// no validation rules for Address

	// no validation rules for Port

	if len(errors) > 0 {
		return LocateRequestBodyMultiError(errors)
	}

	return nil
}

// LocateRequestBodyMultiError is an error wrapping multiple validation errors
// returned by LocateRequestBody.ValidateAll() if the designated constraints
// aren't met.
type LocateRequestBodyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocateRequestBodyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocateRequestBodyMultiError) AllErrors() []error { return m }

// LocateRequestBodyValidationError is the validation error returned by
// LocateRequestBody.Validate if the designated constraints aren't met.
type LocateRequestBodyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocateRequestBodyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocateRequestBodyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocateRequestBodyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocateRequestBodyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocateRequestBodyValidationError) ErrorName() string {
	return "LocateRequestBodyValidationError"
}

// Error satisfies the builtin error interface
func (e LocateRequestBodyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocateRequestBody.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocateRequestBodyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocateRequestBodyValidationError{}

// Validate checks the field values on LocateResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LocateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LocateResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LocateResponseMultiError,
// or nil if none found.
func (m *LocateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LocateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBody()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LocateResponseValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LocateResponseValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBody()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LocateResponseValidationError{
				field:  "Body",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LocateResponseMultiError(errors)
	}

	return nil
}

// LocateResponseMultiError is an error wrapping multiple validation errors
// returned by LocateResponse.ValidateAll() if the designated constraints
// aren't met.
type LocateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocateResponseMultiError) AllErrors() []error { return m }

// LocateResponseValidationError is the validation error returned by
// LocateResponse.Validate if the designated constraints aren't met.
type LocateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocateResponseValidationError) ErrorName() string { return "LocateResponseValidationError" }

// Error satisfies the builtin error interface
func (e LocateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocateResponseValidationError{}

// Validate checks the field values on LocateResponseBody with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LocateResponseBody) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LocateResponseBody with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LocateResponseBodyMultiError, or nil if none found.
func (m *LocateResponseBody) ValidateAll() error {
	return m.validate(true)
}

func (m *LocateResponseBody) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Port

	if len(errors) > 0 {
		return LocateResponseBodyMultiError(errors)
	}

	return nil
}

// LocateResponseBodyMultiError is an error wrapping multiple validation errors
// returned by LocateResponseBody.ValidateAll() if the designated constraints
// aren't met.
type LocateResponseBodyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocateResponseBodyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocateResponseBodyMultiError) AllErrors() []error { return m }

// LocateResponseBodyValidationError is the validation error returned by
// LocateResponseBody.Validate if the designated constraints aren't met.
type LocateResponseBodyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocateResponseBodyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocateResponseBodyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocateResponseBodyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocateResponseBodyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocateResponseBodyValidationError) ErrorName() string {
	return "LocateResponseBodyValidationError"
}

// Error satisfies the builtin error interface
func (e LocateResponseBodyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocateResponseBody.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocateResponseBodyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocateResponseBodyValidationError{}

// Validate checks the field values on ServerMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServerMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServerMessageMultiError, or
// nil if none found.
func (m *ServerMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	switch v := m.Body.(type) {
	case *ServerMessage_Initialize:
		if v == nil {
			err := ServerMessageValidationError{
				field:  "Body",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInitialize()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerMessageValidationError{
						field:  "Initialize",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerMessageValidationError{
						field:  "Initialize",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInitialize()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerMessageValidationError{
					field:  "Initialize",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServerMessage_Accept:
		if v == nil {
			err := ServerMessageValidationError{
				field:  "Body",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAccept()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerMessageValidationError{
						field:  "Accept",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerMessageValidationError{
						field:  "Accept",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAccept()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerMessageValidationError{
					field:  "Accept",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServerMessage_Reject:
		if v == nil {
			err := ServerMessageValidationError{
				field:  "Body",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReject()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerMessageValidationError{
						field:  "Reject",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerMessageValidationError{
						field:  "Reject",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReject()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerMessageValidationError{
					field:  "Reject",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ServerMessageMultiError(errors)
	}

	return nil
}

// ServerMessageMultiError is an error wrapping multiple validation errors
// returned by ServerMessage.ValidateAll() if the designated constraints
// aren't met.
type ServerMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerMessageMultiError) AllErrors() []error { return m }

// ServerMessageValidationError is the validation error returned by
// ServerMessage.Validate if the designated constraints aren't met.
type ServerMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerMessageValidationError) ErrorName() string { return "ServerMessageValidationError" }

// Error satisfies the builtin error interface
func (e ServerMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerMessageValidationError{}

// Validate checks the field values on Initialize with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Initialize) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Initialize with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InitializeMultiError, or
// nil if none found.
func (m *Initialize) ValidateAll() error {
	return m.validate(true)
}

func (m *Initialize) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServerId

	if len(errors) > 0 {
		return InitializeMultiError(errors)
	}

	return nil
}

// InitializeMultiError is an error wrapping multiple validation errors
// returned by Initialize.ValidateAll() if the designated constraints aren't met.
type InitializeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitializeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitializeMultiError) AllErrors() []error { return m }

// InitializeValidationError is the validation error returned by
// Initialize.Validate if the designated constraints aren't met.
type InitializeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitializeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitializeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitializeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitializeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitializeValidationError) ErrorName() string { return "InitializeValidationError" }

// Error satisfies the builtin error interface
func (e InitializeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitialize.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitializeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitializeValidationError{}

// Validate checks the field values on Accept with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Accept) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Accept with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AcceptMultiError, or nil if none found.
func (m *Accept) ValidateAll() error {
	return m.validate(true)
}

func (m *Accept) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	if all {
		switch v := interface{}(m.GetBody()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AcceptValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AcceptValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBody()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AcceptValidationError{
				field:  "Body",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AcceptMultiError(errors)
	}

	return nil
}

// AcceptMultiError is an error wrapping multiple validation errors returned by
// Accept.ValidateAll() if the designated constraints aren't met.
type AcceptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AcceptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AcceptMultiError) AllErrors() []error { return m }

// AcceptValidationError is the validation error returned by Accept.Validate if
// the designated constraints aren't met.
type AcceptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AcceptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AcceptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AcceptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AcceptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AcceptValidationError) ErrorName() string { return "AcceptValidationError" }

// Error satisfies the builtin error interface
func (e AcceptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccept.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AcceptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AcceptValidationError{}

// Validate checks the field values on Reject with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Reject) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Reject with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RejectMultiError, or nil if none found.
func (m *Reject) ValidateAll() error {
	return m.validate(true)
}

func (m *Reject) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	if len(errors) > 0 {
		return RejectMultiError(errors)
	}

	return nil
}

// RejectMultiError is an error wrapping multiple validation errors returned by
// Reject.ValidateAll() if the designated constraints aren't met.
type RejectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RejectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RejectMultiError) AllErrors() []error { return m }

// RejectValidationError is the validation error returned by Reject.Validate if
// the designated constraints aren't met.
type RejectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RejectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RejectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RejectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RejectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RejectValidationError) ErrorName() string { return "RejectValidationError" }

// Error satisfies the builtin error interface
func (e RejectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RejectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RejectValidationError{}

// Validate checks the field values on LocatorMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LocatorMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LocatorMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LocatorMessageMultiError,
// or nil if none found.
func (m *LocatorMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *LocatorMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Body.(type) {
	case *LocatorMessage_Locate:
		if v == nil {
			err := LocatorMessageValidationError{
				field:  "Body",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLocate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LocatorMessageValidationError{
						field:  "Locate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LocatorMessageValidationError{
						field:  "Locate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLocate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LocatorMessageValidationError{
					field:  "Locate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return LocatorMessageMultiError(errors)
	}

	return nil
}

// LocatorMessageMultiError is an error wrapping multiple validation errors
// returned by LocatorMessage.ValidateAll() if the designated constraints
// aren't met.
type LocatorMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocatorMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocatorMessageMultiError) AllErrors() []error { return m }

// LocatorMessageValidationError is the validation error returned by
// LocatorMessage.Validate if the designated constraints aren't met.
type LocatorMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocatorMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocatorMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocatorMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocatorMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocatorMessageValidationError) ErrorName() string { return "LocatorMessageValidationError" }

// Error satisfies the builtin error interface
func (e LocatorMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocatorMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocatorMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocatorMessageValidationError{}

// Validate checks the field values on Locate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Locate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Locate with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LocateMultiError, or nil if none found.
func (m *Locate) ValidateAll() error {
	return m.validate(true)
}

func (m *Locate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	if all {
		switch v := interface{}(m.GetBody()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LocateValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LocateValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBody()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LocateValidationError{
				field:  "Body",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LocateMultiError(errors)
	}

	return nil
}

// LocateMultiError is an error wrapping multiple validation errors returned by
// Locate.ValidateAll() if the designated constraints aren't met.
type LocateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocateMultiError) AllErrors() []error { return m }

// LocateValidationError is the validation error returned by Locate.Validate if
// the designated constraints aren't met.
type LocateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocateValidationError) ErrorName() string { return "LocateValidationError" }

// Error satisfies the builtin error interface
func (e LocateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocateValidationError{}

// Validate checks the field values on EncryptedMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EncryptedMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EncryptedMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EncryptedMessageMultiError, or nil if none found.
func (m *EncryptedMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *EncryptedMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PublicKey

	// no validation rules for Body

	if len(errors) > 0 {
		return EncryptedMessageMultiError(errors)
	}

	return nil
}

// EncryptedMessageMultiError is an error wrapping multiple validation errors
// returned by EncryptedMessage.ValidateAll() if the designated constraints
// aren't met.
type EncryptedMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EncryptedMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EncryptedMessageMultiError) AllErrors() []error { return m }

// EncryptedMessageValidationError is the validation error returned by
// EncryptedMessage.Validate if the designated constraints aren't met.
type EncryptedMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EncryptedMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EncryptedMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EncryptedMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EncryptedMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EncryptedMessageValidationError) ErrorName() string { return "EncryptedMessageValidationError" }

// Error satisfies the builtin error interface
func (e EncryptedMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEncryptedMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EncryptedMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EncryptedMessageValidationError{}
