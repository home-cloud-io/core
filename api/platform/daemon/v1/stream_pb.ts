// @generated by protoc-gen-es v1.6.0 with parameter "target=ts"
// @generated from file platform/daemon/v1/stream.proto (package platform.daemon.stream.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message platform.daemon.stream.v1.DaemonMessage
 */
export class DaemonMessage extends Message<DaemonMessage> {
  /**
   * @generated from oneof platform.daemon.stream.v1.DaemonMessage.message
   */
  message: {
    /**
     * @generated from field: platform.daemon.stream.v1.Heartbeat heartbeat = 1;
     */
    value: Heartbeat;
    case: "heartbeat";
  } | {
    /**
     * @generated from field: platform.daemon.stream.v1.ShutdownAlert shutdown_alert = 2;
     */
    value: ShutdownAlert;
    case: "shutdownAlert";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<DaemonMessage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.daemon.stream.v1.DaemonMessage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "heartbeat", kind: "message", T: Heartbeat, oneof: "message" },
    { no: 2, name: "shutdown_alert", kind: "message", T: ShutdownAlert, oneof: "message" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DaemonMessage {
    return new DaemonMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DaemonMessage {
    return new DaemonMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DaemonMessage {
    return new DaemonMessage().fromJsonString(jsonString, options);
  }

  static equals(a: DaemonMessage | PlainMessage<DaemonMessage> | undefined, b: DaemonMessage | PlainMessage<DaemonMessage> | undefined): boolean {
    return proto3.util.equals(DaemonMessage, a, b);
  }
}

/**
 * @generated from message platform.daemon.stream.v1.ServerMessage
 */
export class ServerMessage extends Message<ServerMessage> {
  /**
   * @generated from oneof platform.daemon.stream.v1.ServerMessage.message
   */
  message: {
    /**
     * @generated from field: platform.daemon.stream.v1.Heartbeat heartbeat = 1;
     */
    value: Heartbeat;
    case: "heartbeat";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ServerMessage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.daemon.stream.v1.ServerMessage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "heartbeat", kind: "message", T: Heartbeat, oneof: "message" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerMessage {
    return new ServerMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerMessage {
    return new ServerMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerMessage {
    return new ServerMessage().fromJsonString(jsonString, options);
  }

  static equals(a: ServerMessage | PlainMessage<ServerMessage> | undefined, b: ServerMessage | PlainMessage<ServerMessage> | undefined): boolean {
    return proto3.util.equals(ServerMessage, a, b);
  }
}

/**
 * @generated from message platform.daemon.stream.v1.Heartbeat
 */
export class Heartbeat extends Message<Heartbeat> {
  constructor(data?: PartialMessage<Heartbeat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.daemon.stream.v1.Heartbeat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Heartbeat {
    return new Heartbeat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Heartbeat {
    return new Heartbeat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Heartbeat {
    return new Heartbeat().fromJsonString(jsonString, options);
  }

  static equals(a: Heartbeat | PlainMessage<Heartbeat> | undefined, b: Heartbeat | PlainMessage<Heartbeat> | undefined): boolean {
    return proto3.util.equals(Heartbeat, a, b);
  }
}

/**
 * @generated from message platform.daemon.stream.v1.ShutdownAlert
 */
export class ShutdownAlert extends Message<ShutdownAlert> {
  constructor(data?: PartialMessage<ShutdownAlert>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.daemon.stream.v1.ShutdownAlert";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShutdownAlert {
    return new ShutdownAlert().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShutdownAlert {
    return new ShutdownAlert().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShutdownAlert {
    return new ShutdownAlert().fromJsonString(jsonString, options);
  }

  static equals(a: ShutdownAlert | PlainMessage<ShutdownAlert> | undefined, b: ShutdownAlert | PlainMessage<ShutdownAlert> | undefined): boolean {
    return proto3.util.equals(ShutdownAlert, a, b);
  }
}

